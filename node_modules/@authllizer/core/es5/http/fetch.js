"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var is_object_1 = require("../utils/is-object");
var base_1 = require("./base");
var extend_1 = require("../utils/extend");
// for fetch global scope error 'TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation'
// can be 'fetch.bind(this)' to solve the error.
var fetchBind = function (input, init) { return fetch(input, init); };
var FetchHttpClient = /** @class */ (function (_super) {
    __extends(FetchHttpClient, _super);
    function FetchHttpClient(client) {
        if (client === void 0) { client = (typeof fetch !== 'undefined' && fetchBind); }
        return _super.call(this, client) || this;
    }
    FetchHttpClient.prototype.request = function (url, options) {
        var method = options.method, data = options.data, params = options.params, _a = options.headers, headers = _a === void 0 ? {} : _a, withCredentials = options.withCredentials;
        url = FetchHttpClient.extendUrlQuery(url, params);
        var credentials = (withCredentials === true && 'include') || (withCredentials === false && 'same-origin') || 'omit';
        // Other types of data can be supported
        if (!headers['Content-Type'] && is_object_1.default(data)) {
            headers = extend_1.default({
                'Content-Type': 'application/json'
            }, headers);
            data = JSON.stringify(data);
        }
        var requestOptions = {
            method: method,
            body: data,
            credentials: credentials,
            headers: headers
        };
        return this._client(url, requestOptions).then(function (response) {
            if (response.ok) {
                return response.json();
            }
            else {
                throw response;
            }
        });
    };
    return FetchHttpClient;
}(base_1.BaseHttpClient));
exports.FetchHttpClient = FetchHttpClient;
//# sourceMappingURL=fetch.js.map