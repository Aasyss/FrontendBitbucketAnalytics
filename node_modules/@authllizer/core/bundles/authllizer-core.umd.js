/**
* @authllizer/core (https://github.com/yisraelx/authllizer#readme)
* @version 0.1.0
* @license MIT
* @copyright Yisrael Eliav <yisraelx@gmail.com> (https://github.com/yisraelx)
*/
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.authllizer = global.authllizer || {}, global.authllizer.core = {})));
}(this, (function (exports) { 'use strict';

(function (AdapterRequestType) {
    AdapterRequestType["signIn"] = "signIn";
    AdapterRequestType["signUp"] = "signUp";
    AdapterRequestType["signOut"] = "signOut";
    AdapterRequestType["authenticate"] = "authenticate";
    AdapterRequestType["link"] = "link";
    AdapterRequestType["unlink"] = "unlink";
    AdapterRequestType["refresh"] = "refresh";
})(exports.AdapterRequestType || (exports.AdapterRequestType = {}));

function isObject(value) {
    return typeof value === 'object';
}

function createMerge(level) {
    if (level === void 0) { level = Infinity; }
    return function (target) {
        if (target === void 0) { target = {}; }
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        var sourcesLength = sources.length;
        for (var i = 0; i < sourcesLength; i++) {
            var source = sources[i] || {};
            var keys = Object.keys(source);
            var keysLength = keys.length;
            for (var j = 0; j < keysLength; j++) {
                var key = keys[j];
                var value = source[key];
                if (level && isObject(value) && !Array.isArray(value) && isObject(target[key]) && !Array.isArray(target[key])) {
                    value = createMerge(--level)({}, target[key], value);
                }
                target[key] = value;
            }
        }
        return target;
    };
}

var merge = createMerge();

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function extendClass(options) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            merge(_this, options);
            return _this;
        }
        return class_1;
    }(this));
}

function isString(value) {
    return typeof value === 'string';
}

function isDefined(value) {
    return value !== undefined && value !== null;
}

function get(object, path, defaultValue) {
    if (!isDefined(path) || path === '') {
        return object;
    }
    var keys = ("" + path).split('.');
    var length = keys.length;
    var result = object;
    for (var i = 0; i < length; i++) {
        var key = keys[i];
        try {
            result = result[key];
        }
        catch (e) {
            return defaultValue;
        }
    }
    return (result !== void 0 ? result : defaultValue);
}

function joinUrl(baseUrl, url) {
    if (/^(?:[a-z]+:)?\/\//i.test(url)) {
        return url;
    }
    var joined = [baseUrl, url].join('/');
    var normalize = function (str) {
        return str
            .replace(/[\/]+/g, '/')
            .replace(/\/\?/g, '?')
            .replace(/\/\#/g, '#')
            .replace(/\:\//g, '://');
    };
    return normalize(joined);
}

var BackendAdapter = /** @class */ (function () {
    function BackendAdapter(httpClient) {
        this.baseUrl = '/auth';
        this.signIn = '/signin';
        this.signOut = '/signout';
        this.signUp = '/signup';
        this.authenticate = '';
        this.link = '';
        this.unlink = '/unlink';
        this.refresh = '/refresh';
        this.defaultHttpOptions = {
            method: 'POST',
            data: {},
            params: {},
            headers: {},
            withCredentials: false
        };
        this.providerInUrl = true;
        this.tokenPath = 'access_token';
        this._httpClient = httpClient;
    }
    BackendAdapter.prototype.request = function (requestOptions) {
        var _this = this;
        var extractToken = requestOptions.extractToken;
        var stateOptions = this.getDefaultRouteOptions(requestOptions);
        var url = this.prepareUrl(requestOptions, stateOptions);
        var httpOptions = this.prepareOptions(requestOptions, stateOptions);
        return this._httpClient.request(url, httpOptions).then(function (response) {
            var adapterResponse = { response: response };
            if (extractToken) {
                adapterResponse.token = _this.extractToken(response);
            }
            return adapterResponse;
        });
    };
    BackendAdapter.prototype.prepareUrl = function (_a, _b) {
        var provider = _a.provider;
        var url = _b.url;
        if (provider && this.providerInUrl) {
            url = joinUrl(url, provider);
        }
        return this.baseUrl ? joinUrl(this.baseUrl, url) : url;
    };
    BackendAdapter.prototype.prepareOptions = function (_a, _b) {
        var token = _a.token, provider = _a.provider, data = _a.data;
        var routeHttpOptions = _b.httpOptions;
        var _c = this, defaultHttpOptions = _c.defaultHttpOptions, providerInUrl = _c.providerInUrl;
        var options = {
            data: {},
            params: {},
            headers: {}
        };
        if (provider && !providerInUrl) {
            data['provider'] = provider;
        }
        if (token) {
            options.headers['Authorization'] = token.toHeader();
        }
        var extendOptions = merge({
            data: {},
            params: {},
            headers: {}
        }, defaultHttpOptions, routeHttpOptions, options);
        extendOptions.method = isString(extendOptions.method) ? extendOptions.method.toUpperCase() : 'POST';
        return this.prepareData(extendOptions, data);
    };
    BackendAdapter.prototype.getDefaultRouteOptions = function (_a) {
        var type = _a.type;
        var options = isString(this[type]) ? { url: this[type] } : this[type] || {};
        options.url = isString(options.url) ? options.url : "/" + type;
        return options;
    };
    BackendAdapter.prototype.prepareData = function (httpOptions, data) {
        var method = httpOptions.method;
        var BODY_METHOD;
        (function (BODY_METHOD) {
            BODY_METHOD[BODY_METHOD["POST"] = 0] = "POST";
            BODY_METHOD[BODY_METHOD["PUT"] = 1] = "PUT";
            BODY_METHOD[BODY_METHOD["PATCH"] = 2] = "PATCH";
        })(BODY_METHOD || (BODY_METHOD = {}));
        if (method in BODY_METHOD) {
            merge(httpOptions.data, data);
            // remove data if data empty
            if (httpOptions.data && !Object.keys(httpOptions.data).length) {
                delete httpOptions.data;
            }
        }
        else {
            merge(httpOptions.params, httpOptions.data, data);
            delete httpOptions.data;
        }
        return httpOptions;
    };
    BackendAdapter.prototype.extractToken = function (response) {
        var tokenPath = this.tokenPath;
        return get(response, tokenPath);
    };
    BackendAdapter.extend = extendClass;
    return BackendAdapter;
}());

function forEach(collection, iteratee) {
    if (collection === void 0) { collection = []; }
    if (iteratee === void 0) { iteratee = function (v) { return v; }; }
    var objectKeys = !Array.isArray(collection) && Object.keys(collection);
    var length = (objectKeys ? objectKeys : collection).length;
    if (!length) {
        return collection;
    }
    var index = 0;
    while (index < length) {
        var key = objectKeys ? objectKeys[index++] : index++;
        var value = collection[key];
        iteratee(value, key, collection);
    }
    return collection;
}

function parseQuery(query) {
    if (query === void 0) { query = ''; }
    var queryObject = {};
    var params = query.split('&');
    forEach(params, function (param) {
        if (param) {
            var pair = param.split('=');
            var key = decodeURIComponent(pair[0]);
            var value = pair[1] ? decodeURIComponent(pair[1]) : true;
            queryObject[key] = value;
        }
    });
    return queryObject;
}

var extend = createMerge(0);

var BaseDialog = /** @class */ (function () {
    function BaseDialog(name, redirectUri, displayOptions) {
        this.name = this.name || name;
        this.redirectUri = this.redirectUri || redirectUri;
        this.setDisplayOptions(displayOptions);
    }
    BaseDialog.parseUrl = function (url) {
        var location = document.createElement('a');
        location.href = url;
        if (location.search || location.hash) {
            var query = parseQuery(location.search.substring(1).replace(/\/$/, ''));
            var hash = parseQuery(location.hash.substring(1).replace(/[\/$]/, ''));
            return extend({}, query, hash);
        }
        else {
            throw new Error('OAuth redirect has occurred but no query or hash parameters were found. ' +
                'They were either not set during the redirect, or were removed—typically by a ' +
                'routing library—before Authllizer could read it.');
        }
    };
    BaseDialog.prototype.setDisplayOptions = function () {
        var displayOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            displayOptions[_i] = arguments[_i];
        }
        this.displayOptions = extend.apply(void 0, [this.displayOptions].concat(displayOptions));
    };
    BaseDialog.extend = extendClass;
    return BaseDialog;
}());

function normalizeLocation(location, _a) {
    var _b = _a === void 0 ? {} : _a, path = _b.path, data = _b.data;
    if (isString(location)) {
        var parser = document.createElement('a');
        parser.href = location;
        location = parser;
    }
    var protocol = location.protocol, hostname = location.hostname, port = location.port, pathname = location.pathname, search = location.search, hash = location.hash;
    var isHttps = protocol === 'https:';
    port = port || (isHttps ? '443' : '80');
    pathname = pathname[0] === '/' ? pathname : "/" + pathname;
    return [
        protocol + "//" + hostname + ":" + port,
        path ? pathname : '',
        data ? (search + hash) : '',
    ].join('');
}

function isFunction(value) {
    return typeof value === 'function';
}

function isRegExp(value) {
    return isObject(value) && value instanceof RegExp;
}

var MemoryStorage = /** @class */ (function () {
    function MemoryStorage(options) {
        if (options === void 0) { options = {}; }
        this.key = 'access_token';
        this._storage = {};
        extend(this, options);
    }
    MemoryStorage.prototype.getToken = function () {
        var key = this.key;
        return this._storage[key];
    };
    MemoryStorage.prototype.setToken = function (token) {
        var key = this.key;
        this._storage[key] = token;
    };
    MemoryStorage.prototype.removeToken = function () {
        var key = this.key;
        delete this._storage[key];
    };
    return MemoryStorage;
}());

var LocalStorage = /** @class */ (function (_super) {
    __extends(LocalStorage, _super);
    function LocalStorage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LocalStorage.prototype.getToken = function () {
        try {
            return localStorage.getItem(this.key);
        }
        catch (e) {
            return _super.prototype.getToken.call(this);
        }
    };
    LocalStorage.prototype.setToken = function (token) {
        try {
            localStorage.setItem(this.key, token.toString());
        }
        catch (e) {
            _super.prototype.setToken.call(this, token);
        }
    };
    LocalStorage.prototype.removeToken = function () {
        try {
            localStorage.removeItem(this.key);
        }
        catch (e) {
            _super.prototype.removeToken.call(this);
        }
    };
    return LocalStorage;
}(MemoryStorage));

function decodeBase64(str) {
    var buffer;
    if (typeof module !== 'undefined' && module.exports) {
        try {
            buffer = require('buffer').Buffer;
        }
        catch (err) {
            // noop
        }
    }
    var fromCharCode = String.fromCharCode;
    var re_btou = new RegExp([
        '[\xC0-\xDF][\x80-\xBF]',
        '[\xE0-\xEF][\x80-\xBF]{2}',
        '[\xF0-\xF7][\x80-\xBF]{3}'
    ].join('|'), 'g');
    var cb_btou = function (cccc) {
        switch (cccc.length) {
            case 4:
                var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                    | ((0x3f & cccc.charCodeAt(1)) << 12)
                    | ((0x3f & cccc.charCodeAt(2)) << 6)
                    | (0x3f & cccc.charCodeAt(3));
                var offset = cp - 0x10000;
                return (fromCharCode((offset >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
            case 3:
                return fromCharCode(((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    | (0x3f & cccc.charCodeAt(2)));
            default:
                return fromCharCode(((0x1f & cccc.charCodeAt(0)) << 6)
                    | (0x3f & cccc.charCodeAt(1)));
        }
    };
    var btou = function (b) {
        return b.replace(re_btou, cb_btou);
    };
    var _decode = buffer ? function (a) {
        return (a.constructor === buffer.constructor
            ? a : new buffer(a, 'base64')).toString();
    }
        : function (a) {
            return btou(atob(a));
        };
    return _decode(String(str).replace(/[-_]/g, function (m0) {
        return m0 === '-' ? '+' : '/';
    })
        .replace(/[^A-Za-z0-9\+\/]/g, ''));
}

/**
 * @resource https://tools.ietf.org/html/rfc7519
 */
var JWT = /** @class */ (function () {
    function JWT(token) {
        this.headerPrefix = 'Bearer';
        this._token = String(token);
        this._payload = JWT.parse(this._token);
    }
    JWT.parse = function (token) {
        if (!isString(token) || !this.JWT_RX.test(token)) {
            throw new Error('Token is invalid or missing.');
        }
        var _a = token.split('.'), base64Url = _a[1];
        var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        return JSON.parse(decodeBase64(base64));
    };
    Object.defineProperty(JWT.prototype, "expire", {
        get: function () {
            var exp = this._payload.exp;
            return new Date(exp * 1000);
        },
        enumerable: true,
        configurable: true
    });
    JWT.prototype.getPayload = function () {
        return this._payload;
    };
    JWT.prototype.isExpired = function () {
        return new Date() > this.expire;
    };
    JWT.prototype.isValid = function () {
        return !this.isExpired();
    };
    JWT.prototype.toHeader = function () {
        return this.headerPrefix + " " + this._token;
    };
    JWT.prototype.toString = function () {
        return this._token;
    };
    JWT.prototype.toJSON = function () {
        return this._payload;
    };
    JWT.JWT_RX = /^[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*$/;
    return JWT;
}());

function stringifyQuery(object, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.encode, encode = _c === void 0 ? false : _c, _d = _b.delimiter, delimiter = _d === void 0 ? ',' : _d;
    var parts = [];
    forEach(object, function (value, key) {
        if (encode) {
            key = encodeURIComponent(key);
            value = encodeURIComponent(value);
        }
        parts.push(key + "=" + value);
    });
    return parts.join(delimiter);
}

function extendUrlQuery(url, params) {
    if (!isObject(params) || !Object.keys(params).length) {
        return url;
    }
    var _a = url.split('?'), path = _a[0], _b = _a[1], query = _b === void 0 ? '' : _b;
    var queryObject = parseQuery(query);
    extend(queryObject, params);
    query = stringifyQuery(queryObject, { encode: true, delimiter: '&' });
    return path + "?" + query;
}

var BaseHttpClient = /** @class */ (function () {
    function BaseHttpClient(client) {
        this._client = client;
    }
    BaseHttpClient.extendUrlQuery = function (url, params) {
        return extendUrlQuery(url, params);
    };
    return BaseHttpClient;
}());

// for fetch global scope error 'TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation'
// can be 'fetch.bind(this)' to solve the error.
var fetchBind = function (input, init) { return fetch(input, init); };
var FetchHttpClient = /** @class */ (function (_super) {
    __extends(FetchHttpClient, _super);
    function FetchHttpClient(client) {
        if (client === void 0) { client = (typeof fetch !== 'undefined' && fetchBind); }
        return _super.call(this, client) || this;
    }
    FetchHttpClient.prototype.request = function (url, options) {
        var method = options.method, data = options.data, params = options.params, _a = options.headers, headers = _a === void 0 ? {} : _a, withCredentials = options.withCredentials;
        url = FetchHttpClient.extendUrlQuery(url, params);
        var credentials = (withCredentials === true && 'include') || (withCredentials === false && 'same-origin') || 'omit';
        // Other types of data can be supported
        if (!headers['Content-Type'] && isObject(data)) {
            headers = extend({
                'Content-Type': 'application/json'
            }, headers);
            data = JSON.stringify(data);
        }
        var requestOptions = {
            method: method,
            body: data,
            credentials: credentials,
            headers: headers
        };
        return this._client(url, requestOptions).then(function (response) {
            if (response.ok) {
                return response.json();
            }
            else {
                throw response;
            }
        });
    };
    return FetchHttpClient;
}(BaseHttpClient));

var Config = /** @class */ (function () {
    function Config(options) {
        this._options = {
            adapter: BackendAdapter,
            dialog: BrowserDialog,
            httpClient: new FetchHttpClient(),
            interceptList: [],
            storage: new LocalStorage(),
            token: JWT
        };
        this.setOptions(options);
    }
    Object.defineProperty(Config.prototype, "adapter", {
        get: function () {
            var Adapter = this._options.adapter;
            if (!isFunction(Adapter)) {
                throw new Error("Config: 'adapter' is missing.");
            }
            return new Adapter(this.httpClient);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "dialog", {
        get: function () {
            var dialog = this._options.dialog;
            if (!isFunction(dialog)) {
                throw new Error("Config: 'dialog' is missing.");
            }
            return dialog;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "httpClient", {
        get: function () {
            var httpClient = this._options.httpClient;
            if (!isObject(httpClient)) {
                throw new Error("Config: 'httpClient' is missing.");
            }
            return httpClient;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "interceptList", {
        get: function () {
            var interceptList = this._options.interceptList;
            return interceptList || [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "storage", {
        get: function () {
            var storage = this._options.storage;
            if (!isObject(storage)) {
                throw new Error("Config: 'storage' is missing.");
            }
            return storage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "token", {
        get: function () {
            var token = this._options.token;
            if (!isFunction(token)) {
                throw new Error("Config: 'token' is missing.");
            }
            return token;
        },
        enumerable: true,
        configurable: true
    });
    Config.prototype.setOptions = function (options) {
        var _this = this;
        if (!isObject(options)) {
            return;
        }
        var adapter = options.adapter, dialog = options.dialog, httpClient = options.httpClient, interceptList = options.interceptList, storage = options.storage, token = options.token, providers = options.providers;
        if (adapter) {
            if (!isFunction(adapter)) {
                throw new Error("Config: 'adapter' is invalid.");
            }
            this._options.adapter = adapter;
        }
        if (dialog) {
            if (!isFunction(dialog)) {
                throw new Error("Config: 'dialog' is  invalid.");
            }
            this._options.dialog = dialog;
        }
        if (httpClient) {
            if (!isObject(httpClient)) {
                throw new Error("Config: 'httpClient' is  invalid.");
            }
            this._options.httpClient = httpClient;
        }
        if (interceptList) {
            if (!Array.isArray(interceptList)) {
                throw new Error("Config: 'interceptList' is  invalid.");
            }
            interceptList.forEach(function (compere) {
                if (!isString(compere) && !isRegExp(compere)) {
                    throw new Error("Config: 'interceptList' invalid compere " + compere);
                }
            });
            this._options.interceptList = interceptList;
        }
        if (storage) {
            if (!isObject(storage)) {
                throw new Error("Config: 'storage' is invalid.");
            }
            this._options.storage = storage;
        }
        if (token) {
            if (!isFunction(token)) {
                throw new Error("Config: 'token' is invalid.");
            }
            this._options.token = token;
        }
        if (providers) {
            if (!isObject(providers)) {
                throw new Error("Config: 'providers' is invalid.");
            }
            if (!isObject(this._options.providers)) {
                this._options.providers = {};
            }
            forEach(providers, function (provider, name) {
                if (!isFunction(provider)) {
                    throw new Error("Config: 'provider' '" + name + "' is invalid.");
                }
                _this._options.providers[name] = provider;
            });
        }
    };
    Config.prototype.provider = function (provider) {
        var providers = this._options.providers;
        if (!isString(provider) || !this.isProviderExists(provider)) {
            throw new Error("Config: '" + provider + "' provider is missing.");
        }
        var Provider = providers[provider];
        if (!isFunction(Provider)) {
            throw new Error("Config: provider should be a class: " + Provider);
        }
        return new Provider(this.adapter, this.dialog);
    };
    Config.prototype.isProviderExists = function (provider) {
        var _a = this._options.providers, providers = _a === void 0 ? {} : _a;
        return !!providers[provider];
    };
    Config.prototype.isUrlMatchInterceptList = function (url) {
        var interceptList = this.interceptList;
        var length = (interceptList || []).length;
        if (!length) {
            return true;
        }
        for (var i = 0; i < length; i++) {
            var compereUrl = interceptList[i];
            if (isString(compereUrl)) {
                if (normalizeLocation(url) === normalizeLocation(compereUrl)) {
                    return true;
                }
            }
            else if (isRegExp(compereUrl)) {
                if (compereUrl.test(url)) {
                    return true;
                }
            }
        }
        return false;
    };
    Config.Promise = (typeof Promise !== 'undefined' && Promise) || (typeof ES6Promise !== 'undefined' && ES6Promise);
    return Config;
}());

var PopupDialog = /** @class */ (function (_super) {
    __extends(PopupDialog, _super);
    function PopupDialog() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(PopupDialog.prototype, "stringDisplayOptions", {
        get: function () {
            return stringifyQuery(this.displayOptions);
        },
        enumerable: true,
        configurable: true
    });
    PopupDialog.prototype.close = function () {
        if (this._popup && isObject(this._popup) && isFunction(this._popup.close)) {
            this._popup.close();
        }
    };
    PopupDialog.prototype.focus = function () {
        if (this._popup && isObject(this._popup) && isFunction(this._popup.focus)) {
            this._popup.focus();
        }
    };
    PopupDialog.prototype.isClosed = function () {
        return !this._popup || this._popup.closed || this._popup.closed === void 0;
    };
    return PopupDialog;
}(BaseDialog));

var BrowserDialog = /** @class */ (function (_super) {
    __extends(BrowserDialog, _super);
    function BrowserDialog() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BrowserDialog.prototype, "dialogName", {
        get: function () {
            return window.navigator.userAgent.indexOf('CriOS') > -1 ? '_blank' : this.name;
        },
        enumerable: true,
        configurable: true
    });
    BrowserDialog.prototype.setDisplayOptions = function (displayOptions) {
        if (displayOptions === void 0) { displayOptions = {}; }
        displayOptions.height = displayOptions.height || 500;
        displayOptions.width = displayOptions.width || 500;
        _super.prototype.setDisplayOptions.call(this, {
            top: window.screenY + ((window.outerHeight - displayOptions.height) / 2.5),
            left: window.screenX + ((window.outerWidth - displayOptions.width) / 2)
        }, displayOptions);
    };
    BrowserDialog.prototype.open = function (url) {
        this._popup = window.open(url, this.dialogName, this.stringDisplayOptions);
        this.focus();
        return this.listen().then(function (url) {
            return BrowserDialog.parseUrl(url);
        });
    };
    BrowserDialog.prototype.listen = function () {
        var _this = this;
        return new Config.Promise(function (resolve, reject) {
            var redirectUri = normalizeLocation(_this.redirectUri, { path: true });
            var intervalId = setInterval(function () {
                if (_this.isClosed()) {
                    clearInterval(intervalId);
                    return reject(new Error('The dialog was closed'));
                }
                try {
                    var url = normalizeLocation(_this._popup.location, { path: true, data: true });
                    if (url.indexOf(redirectUri) === 0) {
                        _this.close();
                        clearInterval(intervalId);
                        resolve(url);
                    }
                }
                catch (error) {
                    // Ignore DOMException: Blocked a frame with origin from accessing a cross-origin frame.
                    // A hack to get around same-origin security policy errors in IE.
                }
            }, 500);
        });
    };
    return BrowserDialog;
}(PopupDialog));

var BaseProvider = /** @class */ (function () {
    function BaseProvider(adapter, dialogClass) {
        this.redirectUri = window.location.origin;
        this._adapter = this._adapter || adapter;
        this._dialog = this._dialog || dialogClass;
    }
    BaseProvider.prototype.openDialog = function (url) {
        var _this = this;
        var _a = this, Dialog = _a._dialog, name = _a.name, redirectUri = _a.redirectUri, displayOptions = _a.displayOptions;
        var dialog = new Dialog(name, redirectUri, displayOptions);
        return dialog.open(url).then(function (response) {
            _this.checkDialogResponse(response);
            return response;
        });
    };
    /**
     * this method can be overridden, for handling unique provider dialog errors
     * @param params
     */
    BaseProvider.prototype.checkDialogResponse = function (params) {
        if (params === void 0) { params = {}; }
        if (params.error) {
            throw new Error(params.error);
        }
    };
    BaseProvider.prototype.prepareData = function (requestKeys) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var params = {};
        var data = extend.apply(void 0, args);
        forEach(requestKeys, function (requestKey, key) {
            if (!key) {
                return;
            }
            var value = data[key] || _this[key];
            if (value) {
                params[requestKey] = value;
            }
        });
        return params;
    };
    BaseProvider.extend = extendClass;
    return BaseProvider;
}());

/**
 * @resource https://tools.ietf.org/html/rfc5849
 */
var OAuth1Provider = /** @class */ (function (_super) {
    __extends(OAuth1Provider, _super);
    function OAuth1Provider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.requestTokenParams = {
            redirectUri: 'callback'
        };
        _this.authenticateParams = {
            redirectUri: 'callback',
            oauth_token: 'oauth_token',
            oauth_verifier: 'oauth_verifier'
        };
        return _this;
    }
    OAuth1Provider.prototype.authenticate = function (requestOptions) {
        var _this = this;
        return this.getRequestToken(requestOptions).then(function (requestTokenResponse) {
            return _this.getPermissions(requestTokenResponse).then(function (dialogResponse) {
                return _this.getAccessToken(dialogResponse, requestOptions);
            });
        });
    };
    OAuth1Provider.prototype.getRequestToken = function (_a) {
        var provider = _a.provider, type = _a.type, token = _a.token;
        var requestTokenParams = this.requestTokenParams;
        var data = this.prepareData(requestTokenParams);
        var options = {
            type: type,
            data: data,
            provider: provider,
            token: token
        };
        return this._adapter.request(options).then(function (_a) {
            var response = _a.response;
            return response;
        });
    };
    OAuth1Provider.prototype.getPermissions = function (requestTokenResponse) {
        var query = stringifyQuery(requestTokenResponse, { delimiter: '&' });
        var url = [this.authorizationEndpoint, query].join('?');
        return this.openDialog(url);
    };
    OAuth1Provider.prototype.getAccessToken = function (oauthData, requestOptions) {
        var authenticateParams = this.authenticateParams;
        var data = this.prepareData(authenticateParams, oauthData);
        requestOptions.data = extend(data, requestOptions.data);
        return this._adapter.request(requestOptions);
    };
    return OAuth1Provider;
}(BaseProvider));

function randomString() {
    return Math.random().toString(36).substr(2);
}

function camelCase(name) {
    return name.replace(/([\:\-\_\.]+(.))/g, function (_, separator, letter, offset) {
        return offset ? letter.toUpperCase() : letter;
    });
}

/**
 * @resource https://tools.ietf.org/html/rfc6749
 */
var OAuth2Provider = /** @class */ (function (_super) {
    __extends(OAuth2Provider, _super);
    function OAuth2Provider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.responseType = 'code';
        _this.baseDialogParams = ['client_id', 'scope', 'state', 'redirect_uri', 'response_type'];
        _this.authenticateParams = {
            code: 'code',
            clientId: 'client_id',
            redirectUri: 'redirect_uri'
        };
        return _this;
    }
    Object.defineProperty(OAuth2Provider.prototype, "scope", {
        get: function () {
            var _a = this, _b = _a.scopeParams, scopeParams = _b === void 0 ? [] : _b, scopePrefix = _a.scopePrefix, scopeDelimiter = _a.scopeDelimiter;
            var stringScope = scopeParams.join(scopeDelimiter);
            if (stringScope === '') {
                return void 0;
            }
            return scopePrefix ? [scopePrefix, stringScope].join(scopeDelimiter) : stringScope;
        },
        enumerable: true,
        configurable: true
    });
    OAuth2Provider.prototype.authenticate = function (requestOptions) {
        var _this = this;
        this.state = this.state || randomString();
        return this.getPermissions().then(function (dialogResponse) {
            return _this.getAccessToken(dialogResponse, requestOptions);
        });
    };
    OAuth2Provider.prototype.getPermissions = function () {
        var _this = this;
        var _a = this, baseDialogParams = _a.baseDialogParams, dialogParams = _a.dialogParams;
        var keys = [].concat(baseDialogParams || [], dialogParams || []);
        var params = [];
        forEach(keys, function (key) {
            var camelKey = camelCase(key);
            var value = _this[camelKey];
            if (value != void 0) {
                params.push(key + "=" + value);
            }
        });
        var query = params.join('&');
        var url = [this.authorizationEndpoint, query].join('?');
        return this.openDialog(url);
    };
    OAuth2Provider.prototype.getAccessToken = function (oauthData, requestOptions) {
        if (this.state && oauthData.state !== this.state) {
            return Config.Promise.reject(new Error('The value returned in the state parameter does not match the state value from your original authorization code request.'));
        }
        if (this.responseType === 'token') {
            var token = oauthData.access_token;
            return Config.Promise.resolve({ token: token, response: oauthData });
        }
        var authenticateParams = this.authenticateParams;
        var data = this.prepareData(authenticateParams, oauthData);
        requestOptions.data = extend(data, requestOptions.data);
        return this._adapter.request(requestOptions);
    };
    return OAuth2Provider;
}(BaseProvider));

var CookieStorage = /** @class */ (function (_super) {
    __extends(CookieStorage, _super);
    function CookieStorage(options) {
        return _super.call(this, options) || this;
    }
    CookieStorage.prototype.getToken = function () {
        var result;
        try {
            var items = document.cookie.split(';');
            var length_1 = items.length;
            for (var i = 0; i < length_1; i++) {
                var _a = items[i].split('='), key = _a[0], value = _a[1];
                if (key.trim() === this.key) {
                    result = value;
                    break;
                }
            }
        }
        catch (e) {
            result = _super.prototype.getToken.call(this);
        }
        return result;
    };
    CookieStorage.prototype.setToken = function (token) {
        var expire = token.expire || (isFunction(this.expire) ? this.expire() : this.expire);
        this._setToken(token, expire);
    };
    CookieStorage.prototype.removeToken = function () {
        this._setToken('', 0);
    };
    CookieStorage.prototype._setToken = function (token, expire) {
        try {
            document.cookie = [
                this.key + "=" + token,
                expire ? "expires=" + new Date(expire).toUTCString() : '',
                this.path ? "path=" + this.path : ''
            ].join(';');
        }
        catch (e) {
            _super.prototype.setToken.call(this, token);
        }
    };
    return CookieStorage;
}(MemoryStorage));

var SessionStorage = /** @class */ (function (_super) {
    __extends(SessionStorage, _super);
    function SessionStorage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SessionStorage.prototype.getToken = function () {
        try {
            return sessionStorage.getItem(this.key);
        }
        catch (e) {
            return _super.prototype.getToken.call(this);
        }
    };
    SessionStorage.prototype.setToken = function (token) {
        try {
            sessionStorage.setItem(this.key, token.toString());
        }
        catch (e) {
            _super.prototype.setToken.call(this, token);
        }
    };
    SessionStorage.prototype.removeToken = function () {
        try {
            sessionStorage.removeItem(this.key);
        }
        catch (e) {
            _super.prototype.removeToken.call(this);
        }
    };
    return SessionStorage;
}(MemoryStorage));

var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        var listeners = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            listeners[_i] = arguments[_i];
        }
        this._listeners = [];
        this.on.apply(this, listeners);
    }
    EventEmitter.prototype.emit = function (value) {
        forEach(this._listeners, function (listener) {
            listener(value);
        });
        return this;
    };
    EventEmitter.prototype.on = function () {
        var _this = this;
        var listeners = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            listeners[_i] = arguments[_i];
        }
        forEach(listeners, function (listener) {
            if (isFunction(listener)) {
                _this._listeners.push(listener);
            }
        });
        return this;
    };
    EventEmitter.prototype.remove = function () {
        var _this = this;
        var listeners = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            listeners[_i] = arguments[_i];
        }
        forEach(listeners, function (listener) {
            var index = _this._listeners.indexOf(listener);
            if (index > -1) {
                _this._listeners.splice(index, 1);
            }
        });
        return this;
    };
    return EventEmitter;
}());

var Authllizer = /** @class */ (function () {
    function Authllizer(options) {
        if (options === void 0) { options = {}; }
        this._config = new Config;
        this.onChange = new EventEmitter();
        if (options.useClassInstance !== false) {
            return Authllizer.instance.config(options);
        }
        this.config(options);
    }
    Object.defineProperty(Authllizer, "instance", {
        get: function () {
            if (!this.__instance) {
                this.__instance = new Authllizer({ useClassInstance: false });
            }
            return this.__instance;
        },
        enumerable: true,
        configurable: true
    });
    Authllizer.prototype.config = function (options) {
        this._config.setOptions(options);
        return this;
    };
    Authllizer.prototype.signIn = function (data) {
        var _this = this;
        var options = {
            type: exports.AdapterRequestType.signIn,
            data: data,
            extractToken: true
        };
        return this._config.adapter.request(options).then(function (_a) {
            var response = _a.response, token = _a.token;
            _this.setToken(token);
            return response;
        });
    };
    Authllizer.prototype.signUp = function (data, signIn) {
        var _this = this;
        var options = {
            type: exports.AdapterRequestType.signUp,
            data: data,
            extractToken: signIn
        };
        return this._config.adapter.request(options).then(function (_a) {
            var response = _a.response, token = _a.token;
            if (signIn) {
                _this.setToken(token);
            }
            return response;
        });
    };
    Authllizer.prototype.signOut = function (data) {
        var _this = this;
        var options = {
            type: exports.AdapterRequestType.signOut,
            data: data,
            token: this.getToken()
        };
        return this._config.adapter.request(options).then(function (_a) {
            var response = _a.response;
            _this.removeToken();
            return response;
        });
    };
    Authllizer.prototype.authenticate = function (provider, data) {
        var _this = this;
        var options = {
            type: exports.AdapterRequestType.authenticate,
            data: data,
            extractToken: true,
            provider: provider
        };
        return this._config.provider(provider).authenticate(options).then(function (_a) {
            var response = _a.response, token = _a.token;
            _this.setToken(token);
            return response;
        });
    };
    Authllizer.prototype.link = function (provider, data) {
        var options = {
            type: exports.AdapterRequestType.link,
            data: data,
            token: this.getToken(),
            provider: provider
        };
        return this._config.provider(provider).authenticate(options).then(function (_a) {
            var response = _a.response;
            return response;
        });
    };
    Authllizer.prototype.unlink = function (provider, data) {
        var options = {
            type: exports.AdapterRequestType.unlink,
            data: extend({ provider: provider }, data),
            token: this.getToken()
        };
        return this._config.adapter.request(options).then(function (_a) {
            var response = _a.response;
            return response;
        });
    };
    Authllizer.prototype.refresh = function (data) {
        var _this = this;
        var options = {
            type: exports.AdapterRequestType.refresh,
            data: data,
            token: this.getToken(),
            extractToken: true
        };
        return this._config.adapter.request(options).then(function (_a) {
            var token = _a.token, response = _a.response;
            _this.setToken(token);
            return response;
        });
    };
    Authllizer.prototype.isAuthenticated = function () {
        var token = this.getToken();
        return token ? token.isValid() : false;
    };
    Authllizer.prototype.getToken = function () {
        var token = this._config.storage.getToken();
        var Token = this._config.token;
        var tokenObject;
        try {
            tokenObject = new Token(token);
        }
        catch (e) {
        }
        return tokenObject;
    };
    Authllizer.prototype.setToken = function (token) {
        if (isString(token)) {
            var Token = this._config.token;
            token = new Token(token);
        }
        this._config.storage.setToken(token);
        this.onChange.emit(true);
    };
    Authllizer.prototype.removeToken = function () {
        this._config.storage.removeToken();
        this.onChange.emit(false);
    };
    /**
     * for easily create intercepts, checking if necessary to intercept
     * this method checks to see if there is an authenticated user and if there is a match in config.interceptList
     * @param {string} url - url to check
     * @returns {boolean} - if need to intercept
     */
    Authllizer.prototype.toIntercept = function (url) {
        return this.isAuthenticated() && this._config.isUrlMatchInterceptList(url);
    };
    return Authllizer;
}());

var index = Authllizer.instance;

exports.default = index;
exports.EventEmitter = EventEmitter;
exports.BackendAdapter = BackendAdapter;
exports.BaseDialog = BaseDialog;
exports.BrowserDialog = BrowserDialog;
exports.PopupDialog = PopupDialog;
exports.BaseHttpClient = BaseHttpClient;
exports.FetchHttpClient = FetchHttpClient;
exports.BaseProvider = BaseProvider;
exports.OAuth1Provider = OAuth1Provider;
exports.OAuth2Provider = OAuth2Provider;
exports.CookieStorage = CookieStorage;
exports.LocalStorage = LocalStorage;
exports.MemoryStorage = MemoryStorage;
exports.SessionStorage = SessionStorage;
exports.JWT = JWT;
exports.Authllizer = Authllizer;
exports.Config = Config;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=authllizer-core.umd.js.map
