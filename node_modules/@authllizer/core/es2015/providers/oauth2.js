/**
 * @resource https://tools.ietf.org/html/rfc6749
 */
import extend from '../utils/extend';
import forEach from '../utils/for-each';
import randomString from '../utils/random-string';
import camelCase from '../utils/camel-case';
import { Config } from '../config';
import { BaseProvider } from './base';
export class OAuth2Provider extends BaseProvider {
    constructor() {
        super(...arguments);
        this.responseType = 'code';
        this.baseDialogParams = ['client_id', 'scope', 'state', 'redirect_uri', 'response_type'];
        this.authenticateParams = {
            code: 'code',
            clientId: 'client_id',
            redirectUri: 'redirect_uri'
        };
    }
    get scope() {
        let { scopeParams = [], scopePrefix, scopeDelimiter } = this;
        let stringScope = scopeParams.join(scopeDelimiter);
        if (stringScope === '') {
            return void 0;
        }
        return scopePrefix ? [scopePrefix, stringScope].join(scopeDelimiter) : stringScope;
    }
    authenticate(requestOptions) {
        this.state = this.state || randomString();
        return this.getPermissions().then((dialogResponse) => {
            return this.getAccessToken(dialogResponse, requestOptions);
        });
    }
    getPermissions() {
        let { baseDialogParams, dialogParams } = this;
        let keys = [].concat(baseDialogParams || [], dialogParams || []);
        let params = [];
        forEach(keys, (key) => {
            let camelKey = camelCase(key);
            let value = this[camelKey];
            if (value != void 0) {
                params.push(`${key}=${value}`);
            }
        });
        let query = params.join('&');
        let url = [this.authorizationEndpoint, query].join('?');
        return this.openDialog(url);
    }
    getAccessToken(oauthData, requestOptions) {
        if (this.state && oauthData.state !== this.state) {
            return Config.Promise.reject(new Error('The value returned in the state parameter does not match the state value from your original authorization code request.'));
        }
        if (this.responseType === 'token') {
            let token = oauthData.access_token;
            return Config.Promise.resolve({ token, response: oauthData });
        }
        let { authenticateParams } = this;
        let data = this.prepareData(authenticateParams, oauthData);
        requestOptions.data = extend(data, requestOptions.data);
        return this._adapter.request(requestOptions);
    }
}
//# sourceMappingURL=oauth2.js.map