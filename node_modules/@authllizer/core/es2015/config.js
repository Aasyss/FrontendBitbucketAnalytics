import isFunction from './utils/is-function';
import isString from './utils/is-string';
import isObject from './utils/is-object';
import forEach from './utils/for-each';
import normalizeLocation from './utils/normalize-location';
import isRegExp from './utils/is-regexp';
import { LocalStorage } from './storages/local';
import { JWT } from './tokens/jwt';
import { BackendAdapter } from './adapters/backend';
import { BrowserDialog } from './dialogs/browser';
import { FetchHttpClient } from './http/fetch';
export class Config {
    constructor(options) {
        this._options = {
            adapter: BackendAdapter,
            dialog: BrowserDialog,
            httpClient: new FetchHttpClient(),
            interceptList: [],
            storage: new LocalStorage(),
            token: JWT
        };
        this.setOptions(options);
    }
    get adapter() {
        let { adapter: Adapter } = this._options;
        if (!isFunction(Adapter)) {
            throw new Error(`Config: 'adapter' is missing.`);
        }
        return new Adapter(this.httpClient);
    }
    get dialog() {
        let { dialog } = this._options;
        if (!isFunction(dialog)) {
            throw new Error(`Config: 'dialog' is missing.`);
        }
        return dialog;
    }
    get httpClient() {
        let { httpClient } = this._options;
        if (!isObject(httpClient)) {
            throw new Error(`Config: 'httpClient' is missing.`);
        }
        return httpClient;
    }
    get interceptList() {
        let { interceptList } = this._options;
        return interceptList || [];
    }
    get storage() {
        let { storage } = this._options;
        if (!isObject(storage)) {
            throw new Error(`Config: 'storage' is missing.`);
        }
        return storage;
    }
    get token() {
        let { token } = this._options;
        if (!isFunction(token)) {
            throw new Error(`Config: 'token' is missing.`);
        }
        return token;
    }
    setOptions(options) {
        if (!isObject(options)) {
            return;
        }
        let { adapter, dialog, httpClient, interceptList, storage, token, providers } = options;
        if (adapter) {
            if (!isFunction(adapter)) {
                throw new Error(`Config: 'adapter' is invalid.`);
            }
            this._options.adapter = adapter;
        }
        if (dialog) {
            if (!isFunction(dialog)) {
                throw new Error(`Config: 'dialog' is  invalid.`);
            }
            this._options.dialog = dialog;
        }
        if (httpClient) {
            if (!isObject(httpClient)) {
                throw new Error(`Config: 'httpClient' is  invalid.`);
            }
            this._options.httpClient = httpClient;
        }
        if (interceptList) {
            if (!Array.isArray(interceptList)) {
                throw new Error(`Config: 'interceptList' is  invalid.`);
            }
            interceptList.forEach((compere) => {
                if (!isString(compere) && !isRegExp(compere)) {
                    throw new Error(`Config: 'interceptList' invalid compere ${compere}`);
                }
            });
            this._options.interceptList = interceptList;
        }
        if (storage) {
            if (!isObject(storage)) {
                throw new Error(`Config: 'storage' is invalid.`);
            }
            this._options.storage = storage;
        }
        if (token) {
            if (!isFunction(token)) {
                throw new Error(`Config: 'token' is invalid.`);
            }
            this._options.token = token;
        }
        if (providers) {
            if (!isObject(providers)) {
                throw new Error(`Config: 'providers' is invalid.`);
            }
            if (!isObject(this._options.providers)) {
                this._options.providers = {};
            }
            forEach(providers, (provider, name) => {
                if (!isFunction(provider)) {
                    throw new Error(`Config: 'provider' '${name}' is invalid.`);
                }
                this._options.providers[name] = provider;
            });
        }
    }
    provider(provider) {
        let { providers } = this._options;
        if (!isString(provider) || !this.isProviderExists(provider)) {
            throw new Error(`Config: '${provider}' provider is missing.`);
        }
        let Provider = providers[provider];
        if (!isFunction(Provider)) {
            throw new Error(`Config: provider should be a class: ${Provider}`);
        }
        return new Provider(this.adapter, this.dialog);
    }
    isProviderExists(provider) {
        let { providers = {} } = this._options;
        return !!providers[provider];
    }
    isUrlMatchInterceptList(url) {
        let { interceptList } = this;
        let { length } = interceptList || [];
        if (!length) {
            return true;
        }
        for (let i = 0; i < length; i++) {
            let compereUrl = interceptList[i];
            if (isString(compereUrl)) {
                if (normalizeLocation(url) === normalizeLocation(compereUrl)) {
                    return true;
                }
            }
            else if (isRegExp(compereUrl)) {
                if (compereUrl.test(url)) {
                    return true;
                }
            }
        }
        return false;
    }
}
Config.Promise = (typeof Promise !== 'undefined' && Promise) || (typeof ES6Promise !== 'undefined' && ES6Promise);
//# sourceMappingURL=config.js.map